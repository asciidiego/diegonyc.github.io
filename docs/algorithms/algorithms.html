<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <!-- 2021-11-22 Mon 00:52 -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <meta name="viewport" content=
  "width=device-width, initial-scale=1" />

  <title>Algorithms Analysis</title>
  <meta name="author" content="Diego Rodriguez" />
  <meta name="generator" content="Org Mode" />
  <style type="text/css">
/*<![CDATA[*/
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/
  </style>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML">
</script>
</head>

<body>
  <div id="content" class="content">
    <h1 class="title">Algorithms Analysis<br />
    <span class="subtitle">LeetCode Algorithm Analysis</span></h1>

    <div id="table-of-contents" role="doc-toc">
      <h2>Table of Contents</h2>

      <div id="text-table-of-contents" role="doc-toc">
        <ul>
          <li><a href="#orga3be71a">1. Introduction</a></li>

          <li>
            <a href="#orgd8897df">2. Problems</a>

            <ul>
              <li>
                <a href="#orgf37932b">2.1. Range sum of binary
                search tree</a>

                <ul>
                  <li><a href="#org2a829fd">2.1.1. Problem
                  Statement</a></li>

                  <li><a href="#org239320d">2.1.2. Background:
                  Binary Trees</a></li>

                  <li><a href="#orgec08fd4">2.1.3. Problem Solving
                  Process</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <div id="outline-container-orga3be71a" class="outline-2">
      <h2 id="orga3be71a"><span class="section-number-2">1.</span>
      Introduction</h2>

      <div class="outline-text-2" id="text-1">
        <p>While a part of me does not like the process in which
        many students go through LeetCode to land an internship or
        a full-time position at a company, I think solving problems
        and writing about them is fun. Besides, lately I have been
        trying to live more like my role models. In particular,
        Leonardo Da Vinci and Richard Feynman.</p>

        <p>One of the things that I love about them is their
        insatiability for deep knowledge. Whatever it is they do,
        they have to keep digging until they find the truth. A
        seemingly infinite curiosity drives them. Similar to the
        one that drives kids to ask <i>why</i> continuously. In my
        early twenties I set out to be constantly curious as one of
        my driving principles. This document is nothing but another
        attempt at trying to live up to it.</p>

        <blockquote>
          <p>What I cannot create, I do not understand.</p>

          <p>Know how to solve every problem that has been
          solved.</p>

          <p>&mdash;The quote was written on Richard
          Feynman&rsquo;s blackboard at the time of his death in
          1988</p>
        </blockquote>
      </div>
    </div>

    <div id="outline-container-orgd8897df" class="outline-2">
      <h2 id="orgd8897df"><span class="section-number-2">2.</span>
      Problems</h2>

      <div class="outline-text-2" id="text-2"></div>

      <div id="outline-container-orgf37932b" class="outline-3">
        <h3 id="orgf37932b"><span class=
        "section-number-3">2.1.</span> Range sum of binary search
        tree</h3>

        <div class="outline-text-3" id="text-2-1"></div>

        <div id="outline-container-org2a829fd" class="outline-4">
          <h4 id="org2a829fd"><span class=
          "section-number-4">2.1.1.</span> Problem Statement</h4>

          <div class="outline-text-4" id="text-2-1-1">
            <p>Given the root node of a binary search tree and two
            integers (<code>low</code> and <code>high</code>),
            return the sum of the values of all the nodes (\(n_i\))
            such that \(l&lt;= n_i &lt;= h\).</p>

            <p>Assumptions:</p>

            <ul class="org-ul">
              <li>All node values are <b>unique</b>.</li>
            </ul>
          </div>
        </div>

        <div id="outline-container-org239320d" class="outline-4">
          <h4 id="org239320d"><span class=
          "section-number-4">2.1.2.</span> Background: Binary
          Trees</h4>

          <div class="outline-text-4" id="text-2-1-2"></div>

          <ol class="org-ol">
            <li>
              <a id="orgae420ed" name=
              "orgae420ed"></a>Definition<br />

              <div class="outline-text-5" id="text-2-1-2-1">
                <p>A binary tree is a tree data structure in which
                each node has at most two children. That is why is
                called a <i>binary</i> tree.</p>

                <div id="orgbcabcd3" class="figure">
                  <p><img src="binary_tree.svg" alt=
                  "binary_tree.svg" /></p>
                </div>

                <p>Binary trees have interesting properties. These
                are so interesting that today many top-notch
                technology companies ask about those properties at
                job interviews. However, before we can dive into
                the properties of binary trees, we need to learn a
                bit of fancy terminology to understand the alien
                language of computer scientists.</p>

                <ul class="org-ul">
                  <li><b>Sub-tree</b>. Any tree that can be made
                  from the elements already found in another tree.
                  For example, in the example shown above, the tree
                  containing a single root node called &ldquo;Left
                  child node&rdquo; is a sub-tree of our initial
                  binary tree.</li>
                </ul>

                <div id="orge98a2c4" class="figure">
                  <p><img src="sub_tree.svg" alt=
                  "sub_tree.svg" /></p>
                </div>
              </div>
            </li>

            <li>
              <a id="org179d1aa" name=
              "org179d1aa"></a>Properties<br />

              <div class="outline-text-5" id="text-2-1-2-2">
                <ul class="org-ul">
                  <li>A <b>rooted</b> binary tree is one where the
                  tree has a root node and each node has, at most,
                  two children.</li>

                  <li>A <b>full</b> binary tree is one where each
                  node has either \(0\) or \(2\) children.</li>

                  <li>A <b>balanced</b> binary tree is a binary
                  tree in which the left and right sub-trees for
                  every node differ in height by no more than
                  \(1\).</li>
                </ul>
              </div>
            </li>

            <li>
              <a id="orge9fe7b9" name=
              "orge9fe7b9"></a>Representation<br />

              <div class="outline-text-5" id="text-2-1-2-3">
                <p>There are many ways to represent binary trees in
                our computers. One of the most common methods
                involves using <b>arrays</b>.</p>
              </div>

              <ol class="org-ol">
                <li>
                  <a id="org09d5442" name="org09d5442"></a>Using
                  arrays to store trees<br />

                  <div class="outline-text-6" id="text-2-1-2-3-1">
                    <p>Given a node with index \(i\), we can find
                    the left and right sub-nodes at indices \(2i +
                    1\) and \(2i + 2\) respectively. The parent for
                    node \(i\) can be found at \(\lfloor \frac{i -
                    1}{2} \rfloor\) (assuming the root node index
                    is zero).</p>
                  </div>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <div id="outline-container-orgec08fd4" class="outline-4">
          <h4 id="orgec08fd4"><span class=
          "section-number-4">2.1.3.</span> Problem Solving
          Process</h4>

          <div class="outline-text-4" id="text-2-1-3">
            <p>Let us imagine the following graph G for our
            solution.</p>

            <div id="orgdc3ad85" class="figure">
              <p><img src="first_binary_tree.svg" alt=
              "first_binary_tree.svg" /></p>
            </div>

            <p>The first solution I came up with involves simply
            traversing our binary tree (i.e. visiting each and
            every node) and checking if we should add the node
            value to a variable or if we should instead skip it
            (i.e. add 0 to our accumulator). This solution is in
            \(O(n)\). Great! Linear order. Usually that is a good
            algorithm; but, in this case, the structure of our data
            allows us to skip looking at all the values to know the
            solution to our result.</p>

            <p>The problem asks us to sum <b>only if the node value
            is in between a given range</b>. We also know that, if
            we are in a given node, the node to the left has a
            lower value than the current node and the node to the
            right has a bigger value.</p>

            <p>Thus, we have several edge cases that we can
            exploit:</p>

            <ul class="org-ul">
              <li>We are out of range and&hellip;

                <ul class="org-ul">
                  <li>we are above our range. <b>In this case, we
                  know we only have to traverse the tree to the
                  left</b>. Going to the right makes no sense since
                  we already have a too high value. We do
                  <b>not</b> accumulate this value (after all, we
                  are outside the range) and proceed to traverse
                  only to the <b>left</b>.</li>

                  <li>we are below our range. In this other
                  case&mdash;but for the same reason as
                  before&mdash;we know we can skip left traversals
                  and only do right traversals. We do <b>not</b>
                  accumulate this value (after all, we are outside
                  the range) and proceed to traverse only to the
                  <b>right</b>.</li>
                </ul>
              </li>

              <li>We are in the range provided&hellip;

                <ul class="org-ul">
                  <li>and we <b>are at the lower bound</b>. In this
                  case, similar to before, we know we do not have
                  to look to the left, since we are already at the
                  boundary! Thus, we can only keep traversing to
                  the right. However, this time we accumulate the
                  value since we are inside the range.</li>

                  <li>and we <b>are at the higher bound</b>. Again,
                  only to the left and accumulate. I think you are
                  getting it.</li>

                  <li>and we are not the higher nor the lower
                  bound. This is our base case. In this case, we
                  simply accumulate the value of the current node
                  and traverse both to the left and to the
                  right.</li>
                </ul>
              </li>
            </ul>

            <p>This can be done using the following code:</p>

            <div class="org-src-container">
              <pre class="src src-python">
<span class="org-keyword">from</span> typing <span class=
"org-keyword">import</span> Optional


<span class="org-keyword">class</span> <span class=
"org-type">TreeNode</span>:
    <span class="org-keyword">def</span> <span class=
"org-function-name">__init__</span>(<span class=
"org-keyword">self</span>, val=<span class=
"org-highlight-numbers-number">0</span>, left=<span class=
"org-constant">None</span>, right=<span class=
"org-constant">None</span>):
        <span class="org-keyword">self</span>.val = val
        <span class="org-keyword">self</span>.left = left
        <span class="org-keyword">self</span>.right = right

<span class=
"org-variable-name">raw_binary_tree</span> = [<span class=
"org-highlight-numbers-number">10</span>, <span class=
"org-highlight-numbers-number">5</span>, <span class=
"org-highlight-numbers-number">17</span>, <span class=
"org-highlight-numbers-number">3</span>, <span class=
"org-highlight-numbers-number">4</span>, <span class=
"org-highlight-numbers-number">16</span>, <span class=
"org-highlight-numbers-number">19</span>]
<span class="org-keyword">def</span> <span class=
"org-function-name">generate_bts_from_array</span>(storage: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>], root, i, n) -&gt; TreeNode:
    <span class=
"org-doc">"""Return the root node of the generated BTS."""</span>
    <span class="org-keyword">if</span> i &lt; n:
        <span class=
"org-variable-name">temp</span> = TreeNode(storage[i], <span class=
"org-constant">None</span>, <span class="org-constant">None</span>)
        <span class="org-variable-name">root</span> = temp

        <span class=
"org-variable-name">root.left</span> = generate_bts_from_array(storage, root.left, <span class="org-highlight-numbers-number">2</span> * i + <span class="org-highlight-numbers-number">1</span>, n)
        <span class=
"org-variable-name">root.right</span> = generate_bts_from_array(storage, root.left, <span class="org-highlight-numbers-number">2</span> * i + <span class="org-highlight-numbers-number">2</span>, n)
    <span class="org-keyword">return</span> root

<span class=
"org-variable-name">root</span> = generate_bts_from_array(raw_binary_tree, <span class="org-constant">None</span>, <span class="org-highlight-numbers-number">0</span>, <span class="org-builtin">len</span>(raw_binary_tree))

<span class="org-keyword">def</span> <span class=
"org-function-name">sum_from_binary_tree_search</span>(root: Optional[TreeNode], low: <span class="org-builtin">int</span>, high: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-variable-name">accum</span> = <span class=
"org-highlight-numbers-number">0</span>
        <span class="org-variable-name">stack</span> = [root]
        <span class="org-keyword">while</span> stack:
            <span class=
"org-variable-name">node</span> = stack.pop()
            <span class="org-keyword">if</span> <span class=
"org-keyword">not</span> node:
                <span class="org-keyword">continue</span>

            <span class="org-keyword">if</span> node.val &gt; high:
                stack.append(node.left)
            <span class=
"org-keyword">elif</span> node.val &lt; low:
                stack.append(node.right)
            <span class="org-keyword">else</span>:
                <span class=
"org-variable-name">accum</span> += node.val
                stack.append(node.left)
                stack.append(node.right)
        <span class="org-keyword">return</span> accum

<span class=
"org-keyword">assert</span> sum_from_binary_tree_search(root, <span class="org-highlight-numbers-number">0</span>, <span class="org-highlight-numbers-number">1000</span>) == <span class="org-builtin">sum</span>(raw_binary_tree)
<span class="org-keyword">print</span>(<span class=
"org-string">"Total sum of the graph: "</span>, <span class=
"org-builtin">sum</span>(raw_binary_tree))
<span class="org-keyword">print</span>(<span class=
"org-string">"Sum for nodes with values between [3, 5]: "</span>, sum_from_binary_tree_search(root, <span class="org-highlight-numbers-number">3</span>, <span class="org-highlight-numbers-number">5</span>))
</pre>
            </div>
            <pre class="example">
Total sum of the graph:  74
Sum for nodes with values between [3, 5]:  12
</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="postamble" class="status">
    <p class="author">Author: Diego Rodriguez</p>

    <p class="date">Created: 2021-11-22 Mon 00:52</p>
  </div>
</body>
</html>
